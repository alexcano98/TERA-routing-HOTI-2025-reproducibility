
Configuration
{
	random_seed: ![1,2,3],
	warmup: 999999999940000,
	measured: 9999999999940000,
	statistics_server_percentiles: [0,5,25,50,75,95,100],
	statistics_packet_percentiles: [0,5,25,50,75,95,100],
	general_frequency_divisor:2,
	statistics_temporal_step: 1000,
	topology: topologies![
		Hamming
		{
			servers_per_router: 8,
			sides:[8],
			legend_name: "08",
		},
		Hamming
		{
			servers_per_router: 16,
			sides:[16],
			legend_name: "16",
		},
		Hamming
		{
			servers_per_router: 32,
			sides:[32],
			legend_name: "32",
		},
		Hamming
		{
			servers_per_router: 64,
			sides:[64],
			legend_name: "64",
		},
	],
	traffic: Burst{
		pattern: ![
			Product{
				block_size: topologies![8, 16, 32, 64],
				global_pattern: RandomPermutation,
				block_pattern: Identity,
				legend_name: "Random switch permutation"
			},
			FixedRandom{legend_name: "Fixed Random"},
		],
		tasks: topologies![64, 256, 1024, 4096],
		message_size: 20000,
		messages_per_task: 1,
	},
	router: InputOutput
	{
		virtual_channels: mecanismo![1, 1, 1, 1, 2, 2],	
		virtual_channel_policies: mecanismo![
		
			[
					VecLabel{label_vector:[0, 56, 56]},
					OccupancyFunction{label_coefficient:1, occupancy_coefficient:1, product_coefficient:0, constant_coefficient:0, use_internal_space:true,use_neighbour_space:true, aggregate:true},
					LowestLabel, EnforceFlowControl, Random,
			],
			[
					VecLabel{label_vector:[0, 56, 56]},
					OccupancyFunction{label_coefficient:1, occupancy_coefficient:1, product_coefficient:0, constant_coefficient:0, use_internal_space:true,use_neighbour_space:true, aggregate:true},
					LowestLabel, EnforceFlowControl, Random,
			],
			[
					VecLabel{label_vector:[0, 56, 56]},
					OccupancyFunction{label_coefficient:1, occupancy_coefficient:1, product_coefficient:0, constant_coefficient:0, use_internal_space:true,use_neighbour_space:true, aggregate:true},
					LowestLabel, EnforceFlowControl, Random,
			],
			[
					VecLabel{label_vector:[0, 56, 56]},
					OccupancyFunction{label_coefficient:1, occupancy_coefficient:1, product_coefficient:0, constant_coefficient:0, use_internal_space:true,use_neighbour_space:true, aggregate:true},
					LowestLabel, EnforceFlowControl, Random,
			],
			[
					//WideHops{width:1},
					VecLabel{label_vector:[0, 64]},
					OccupancyFunction{label_coefficient:1, occupancy_coefficient:1, product_coefficient:0, constant_coefficient:0, use_internal_space:true,use_neighbour_space:true, aggregate:true},
					OccupancyFunction{label_coefficient:1, occupancy_coefficient:1, product_coefficient:0, constant_coefficient:0, use_internal_space:true,use_neighbour_space:true, aggregate:false},
					LowestLabel, EnforceFlowControl, Random
			],
			[
					WideHops{width:1},
					VecLabel{label_vector:[0, 64]},
					OccupancyFunction{label_coefficient:1, occupancy_coefficient:1, product_coefficient:0, constant_coefficient:0, use_internal_space:true,use_neighbour_space:true, aggregate:true},
					OccupancyFunction{label_coefficient:1, occupancy_coefficient:1, product_coefficient:0, constant_coefficient:0, use_internal_space:true,use_neighbour_space:true, aggregate:false},
					LowestLabel, EnforceFlowControl, Random
			],
		],
		allocator: Random,
		buffer_size: 160, //phits per buffer
		bubble: false,
		flit_size: 16, //phits in each packet. If equal to packet_size then it is virtual cut-through
		intransit_priority: false,
		allow_request_busy_port: true,
		output_buffer_size: 80,
		crossbar_frequency_divisor: 1,
		crossbar_delay: 2,
	
	},

	maximum_packet_size: 16,
	routing: mecanismo![
		
		SubTopologyRouting{
			logical_topology: Mesh{
				sides:topologies![[8], [16], [32], [64]],
				servers_per_router:1
			},
			map: Identity,
			logical_routing: DOR{order:[0]},
			opportunistic_hops:true,
			livelock_avoidance: true,
			legend_name: "TERA-PATH"
		},
	
		SubTopologyRouting{
			logical_topology: Hamming //Hypercube
			{
				servers_per_router: 2, //useless
				sides:topologies![[2, 4], [4, 4], [4, 8], [8, 8]],
			},
			map: Identity,
			logical_routing: DOR{order:[0,1]},
			opportunistic_hops: true,
			legend_name: "TERA-HX2"
		},	
		SubTopologyRouting{
			logical_topology:Tree{
				degree: 4,
				num_routers: topologies![8, 16, 32, 64],
				servers_per_router:1,
			},
			map: Identity,
			logical_routing: Shortest,
			opportunistic_hops:true,
			livelock_avoidance: true,
			legend_name: "TERA-4-Tree"
		},
		SubTopologyRouting{
			logical_topology: Hamming //Hypercube
			{
				servers_per_router: 2, //useless
				sides:topologies![[2, 2, 2], [2, 2, 4], [2, 4, 4], [4, 4, 4]],
			},
			map: Identity,
			logical_routing: DOR{order:[0, 1, 2]},
			opportunistic_hops:true,
			livelock_avoidance:true,
			legend_name: "TERA-HX3"
		},	
		Valiant{
			first: Shortest,
			second: Shortest,
			first_reserved_virtual_channels: [0],
			second_reserved_virtual_channels:[1],
			legend_name: "Valiant"
		},
		Sum{
			policy: TryBoth,
			first_routing: Shortest,
			second_routing: Valiant{
				first: Shortest,
				second: Shortest,
				first_reserved_virtual_channels: [0],
				second_reserved_virtual_channels:[1],
			},
			first_allowed_virtual_channels:[0],
			second_allowed_virtual_channels:[0,1],
			second_extra_label: 1,
			legend_name: "UGAL",
		},
	],
	link_classes: [
		LinkClass
		{
			delay: 2,//1 cycle per link, as default in fsin
			//transference_speed: [1,1],//[X,Y] X phits each Y cycles. Does it make sense this way?
		},
		LinkClass
		{
			delay: 2,//1 cycle per link, as default in fsin
			//transference_speed: [1,1],//[X,Y] X phits each Y cycles. Does it make sense this way?
		},
		LinkClass
		{
			delay: 2,//1 cycle per link, as default in fsin
			//transference_speed: [1,1],//[X,Y] X phits each Y cycles. Does it make sense this way?
		},
		LinkClass
		{
			delay: 2,//1 cycle per link, as default in fsin
			//transference_speed: [1,1],//[X,Y] X phits each Y cycles. Does it make sense this way?
		},
	],
	launch_configurations: [
		Slurm
		{
			job_pack_size: 1,
			sbatch_args:["--exclude=node82,node69,node70,node123"],
			time: "2-10:00:00",
		},
	],
}

