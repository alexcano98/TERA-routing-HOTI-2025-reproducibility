
Configuration
{
	random_seed: ![1,2,3],
	warmup: 9990000,
	measured: 9999990000, //cycles are set very high to avoid the simulation ending before all the traffic to generate is consumed.
	statistics_server_percentiles: [0,5,25,50,75,95,100],
	statistics_packet_percentiles: [0,5,25,50,75,95,100],
	general_frequency_divisor:2, // Unless its is override, 2 cycles of the simulation clock are equivalent to 1 cycle of all the components of the simulation.
	statistics_temporal_step: 1000,
	topology: Hamming //Full-mesh network with 64 switches, each switch connected with 64 servers. Total of 4096 servers.
	{
		servers_per_router: 64,
		sides:[64],
	},
	traffic: Burst{ //traffic which generates a burst of messages at the beginning of the simulation and finishes when all the messages are consumed.
        tasks: 4096, //all the tasks of the traffic. One task is assigned linearly to one server.
		pattern: ![ //a patterns assigns a destination to each task (server) in the network. It goes from the source task coordinates to the destination task.
			CartesianTransform
			{
				sides: [64, 64], //64x64 grid of tasks. tasks are disposed in a 2D grid. First coordinate represent the switch, and the second the coordinate inside.
				shift: [0, 1], //All tasks in a switch send messages to all tasks in the next switch.
				legend_name: "Shift-1",
			},
			Composition{ //several patterns applied in a sequence
				patterns:[
					LinearTransform{ //To obtain the destination, multiply the tasks coordinates by a matrix
						source_size: [64, 64], //64x64 grid of tasks
						matrix: [[1,0], [0, -1]],
						target_size: [64, 64]
					},
					CartesianTransform
					{
						sides: [64, 64],
						shift: [ 0, 63],
					},
				],
				legend_name: "Switch complement"
			},
			Product{
				block_size: 64,//group the tasks in groups of 64,
				global_pattern: RandomPermutation, //apply a randomperm between groups
				block_pattern: Identity, //do not permute the tasks inside the group
				legend_name: "Random switch permutation"
			},	
		],
		messages_per_task: 1,
		message_size: 20000, //phits to send
	},
	router: InputOutput
	{
		virtual_channels: mecanismo![2, 1, 1, 2],	
		virtual_channel_policies: mecanismo![
			[//Valiant
					LowestLabel, EnforceFlowControl, Random
			],
			[//bRINR
					VecLabel{label_vector:[0, 56]},
					OccupancyFunction{label_coefficient:1, occupancy_coefficient:1, product_coefficient:0, constant_coefficient:0, use_internal_space:true,use_neighbour_space:true, aggregate:true},
					LowestLabel, EnforceFlowControl, Random,
			],
			[//sRINR
					VecLabel{label_vector:[0, 56]},
					OccupancyFunction{label_coefficient:1, occupancy_coefficient:1, product_coefficient:0, constant_coefficient:0, use_internal_space:true,use_neighbour_space:true, aggregate:true},
					LowestLabel, EnforceFlowControl, Random,
			],
			[//UGAL
					VecLabel{label_vector:[0, 64]},
					OccupancyFunction{label_coefficient:1, occupancy_coefficient:1, product_coefficient:0, constant_coefficient:0, use_internal_space:true,use_neighbour_space:true, aggregate:true},
					OccupancyFunction{label_coefficient:1, occupancy_coefficient:1, product_coefficient:0, constant_coefficient:0, use_internal_space:true,use_neighbour_space:true, aggregate:false},
					LowestLabel, EnforceFlowControl, Random
			],
		],
		allocator: Random,
		buffer_size: 160, //phits per buffer
		bubble: false,
		flit_size: 16, //phits in each packet. If equal to maximum_packet_size then it is virtual cut-through
		intransit_priority: false,
		allow_request_busy_port: true,
		output_buffer_size: 80,
		crossbar_frequency_divisor: 1, // Speedup of the router is x2 compared to the simulation clock.
		crossbar_delay: 2, //2 cycles to cross the crossbar
	
	},

	maximum_packet_size: 16,
	routing: mecanismo![
		
		Valiant{
			first: Shortest,
			second: Shortest,
			first_reserved_virtual_channels: [0],
			second_reserved_virtual_channels:[1],
			legend_name: "Valiant",
		},
		
		Sum{
			policy: TryBoth,
			first_routing: Shortest,
			second_routing: FMLabel{
				balance_algorithm: bRINR,
			},
			first_allowed_virtual_channels:[0],
			second_allowed_virtual_channels:[0],
			second_extra_label: 1,
			legend_name: "bRINR",
		},

		Sum{
			policy: TryBoth,
			first_routing: Shortest,
			second_routing: FMLabel{
				balance_algorithm:sRINR{
					a:0,
					b:0,
				},
				weight_repetition:true,
			},
			first_allowed_virtual_channels:[0],
			second_allowed_virtual_channels:[0],
			second_extra_label: 1,
			legend_name: "sRINR",
		},
		Sum{
			policy: TryBoth,
			first_routing: Shortest,
			second_routing: Valiant{
				first: Shortest,
				second: Shortest,
				first_reserved_virtual_channels: [0],
				second_reserved_virtual_channels:[1],
			},
			first_allowed_virtual_channels:[0],
			second_allowed_virtual_channels:[0,1],
			second_extra_label: 1,
			legend_name: "UGAL",
		},
	
	],
	link_classes: [
		LinkClass
		{
			delay: 2, //the delay of the link class 0 is 2 cycles. (switch to switch)
		},
		LinkClass
		{
			delay: 2, //the delay of the link class 1 is 2 cycles. (server to switch)
		},
	],
	launch_configurations: [
		Slurm
		{
			job_pack_size: 1,
			time: "2-10:00:00",
		},
	],
}

